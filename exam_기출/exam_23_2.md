1. c언어 결과가 "43215" 일 때, 괄호 안에 들어갈 알맞은 식
```c
#include <stdio.h>
main(){
    int n[] = {5,4,3,2,1};
    for (int i=0;i<5; i++)
        printf("%d", n[(i+1)%5]);
}
```
2. c언어 
```c
#include < stdio.h>
main(){
    int m=4620;
    int a= m/1000;
    int b= m%1000/500;
    int c= m%500/100;
    int d= m%100/10;
    printf("1000원의 개수: %d\n",a);
    printf("500원의 개수: %d\n",b);
    printf("100원의 개수: %d\n",c);
    printf("10원의 개수: %d\n",d);

}
```
3. c 언어 "홍길동" "김철수" "박영희"
```c
#include <stdio.h>
char n[30];
char* getname(){
    printf("이름입력:");
    gets(n);
    return n;

}
main() {
    char* n1 = getname();
    char* n2 = getname();
    char* n3 = getname();
    printf("%s\n", n1);
    printf("%s\n", n2);
    printf("%s\n", n3);
}
```
```
박영희
박영희
박영희
```

4. <학생> 테이블에 (9816021, '한국산',3,'경영학개론','050-1234-1234')인 데이터를 삽입하고자 한다. <처리조건>을 참고하여 적합한 SQL문을 작성하시오.  
    ```
    - 최소한의 코드로 작성될수
    - 명령문 마지막의 세미콜론은 생략이 가능하다.
    - 인용부호가 필요한 경우 작은따옴표를 사용한다.
    ```
=> insert into 학생 values (9816021, '한국산', 3, '경영학개론', '050-1234-1234');

5. c언어 결과
```c
#include <stdio.h>
main(){
    int n[] = {73, 95, 82};
    int sum =0;
    for (int i=0; i<3; i++)
        sum += n[i];
    switch (sum /30){
        case 10:
        case 9: printf("A");
        case 8: printf("B");
        case 7:
        case 6: printf("C");
        default: printf("D");
    }
}
==> BCD
```

6. 화이트박스 테스트의 검증 기준 ==> 조건 커버리지
```
테스트 케이스를 소스 코드의 ㅣ조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 설계한다.
```
* 화이트박스 테스트 - 원시 코드의 논리적인ㄴ 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
    - 기초 경로 검사 : 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
    - 제어 구조 검사 : 조건 검사, 루프 검사, 데이터 흐름 검사
    * 화이트 박스 테스트 검증기준
        - 문장 검증 기준 : 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계
        - 분기 검증 기준 : 소스 코드의 모든 조건문에 대해 조건식의 결과가 True인 경우와 False 인 경우가 한 번 이상 수행 되도록 테스트 케이스를 설계함
        - 분기/조건 기준 : 조건문이 True 인 경우와 False 인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스를 설계함
* 블랙 박스 테스트 - 각 기능이 완전히 작동되는 것을 입증하는 테스트
    - 동치 분할 검사
    - 경계값 분석
    - 원인 효과 그래프 검사
    - 오류 예측 검사
    - 비교 검사

7. C언어 결과
```c
#include <stdio.h>
main(){
    int c=0;
    for (int i=1; i<=2003;i++)
        if(i%4==0)
            c++;
    printf("%d",c);
}
==> 505
```
8. 소프트웨어 데이터의 비정상적인 수정이 감지되면 소프트웨어를 오작동하게 만들어 악용을 방지하는 기술이다. 해시 함수, 핑거 프린트, 워터마킹 등의 보안 요소를 생성하여 소프트웨어에 삽입하고, 실행코드를 난독화하며, 실행 시 원본 비교 및 데이터 확인을 수행함으로써 소프트웨어를 보호하는 이 기술을 가리키는 용어를 쓰시오.
==> 템퍼 프루핑 Tamper Proofing

* 보안 솔루션
    - 보안 솔루션이란 접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템을 말함
    - 주요 보안 솔루션
        - 방화벽 
            - 방화벽은 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용 거부 수정 하는 기능을 가진 침입 차단 시스템
            - 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조임
        - 침입 탐지 시스템(IDS: Intrusion Detection System)
            - 침입 탐지 시스템은 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
            - 오용 탐지(Misuse Detection) : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌
            - 이상 탐지(Anomaly Detection) : 편균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
        - 침입 방지 시스템(IPS : Intrusion Prevention System)
            - 침입 방지 시스템은 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션
            - 침입 방지 시스템은 방화벽과 침입 탐지 시스템을 결합한 것
            - 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단함            
        - 데이터 유출 방지(DLP : Data Leakage/Loss Prevention)
            - 데이터 유출 방지는 내부 정보의 외부 유출을 방지하는 보안 솔루션
            - 사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 메일, 메신저, 웹하드, 네트워크 프린터 등의 사용자 행위를 탐지 통제해 외부로의 유출을 사전에 막음
        - 웹 방화벽(Web firewall)
            - 웹 방화벽은 일반 방화벽이 탐지 못하는 SQL삽입공격, Cross-Site Scriptin(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽
            - 웹 관련 공격을 감시하고공격이 웹 서버에 도달하기 전에 이를 차단해 줌
        - VPN(Virtual Private Network, 가상 사설 통신망)
            - VPN 은 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 봔 솔루션.
            - SSL VPN 
                - PC에 VPN Client 프로그램을 설치하여 VPN 서버에 접속하는 방식으로, 암호화를 위해 SSL 프고토콜을 사용함
            - IPSec VPN 
                - VPN  서버가 설치된 각각의 네트워크를 서로 연결하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용함
        - NAC(Network Access Control)
            - NAC 은 네트워크에 접속하는 내부 PC의 MAC 주소를 IP관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
            - 내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지함
        - SIEM(Security Information and Event Management)
            - SIEM 은 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합관리하는 빅 데이터 기반의 보안 솔루션.
            - 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있음
            - 장기간의 로그 및 보안 이벤트를 수집 및 검색할 수 있는 빅데이터 기반의 통합 로그 수집 시스템.
            - __SIM(Security Information Management) + SEM(Security Event Management)__
        * ESM(Enterprise Security Management)
            - SIEM과 기능은 동일하지만 잛은 기간의 로그 및 보안 이벤트를 관리하는 보안 솔루션            
        - SSH(Secure SHell, 시큐어 셸)  
            - SSH는 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램
            - 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신 할 수 있음
            - 키를 통한 인증 방업을 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 함.
            - 기본적으로는 22번 포트를 사용함
        - 템퍼 프루핌(Tamper Proofing)
            - 템퍼 프루핑은 소프트웨어의 위변조가 발생할 경울 소프트웨어를 오작동하게 만들어 악용을 방지하는 기술
            - 템퍼 프루핑은 해시 함수(Hash Function), 핑거 프린트(Fingerprint), 워터마킹(Watermark) 등의 보안 요소를 생성하여 소프트웨어에 삽입하고, 실행 코드를 난독화하며, 실행 시 원본 비교 및 데이터 확인을 수행함으로써 소프트웨어를 보호함
        - OAuth(Open Authorization, 공개인증)
            - 인터넷 애플리케이션에서 사용자 인증에 사용되는 공개 API(OpenAPI)로 구현된 표준 인증 방법
            - 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있음.
            - 2010년 ETF에서 1.0이 공식 표준안으로 발표되었음.

9. c언어 결과
```c
#include <stdio.h>
#define MAX_SIZE 10

int isWhat[MAX_SIZE];
int point = -1;

int isEmpty(){
    if (point == -1 ) return 1;
    return 0;
}
int isFull(){
    if (point == 10) return 1;
    return 0;
}
void into(int num){
    if(isFull() ==1 ) printf("Full");
    else iswhat[++point] = num;
}
int take(){
    if(isEmpty() == 1) printf("Empty");
    else return isWhat[point--];
    return 0;
}
main(){
    into(5); into(2);
    while(!isEmpty());
        printf("%d", take());
        into(4); into(1); printf("%d", take());
        into(3); printf("%d", take()); printf("%d", take());
        intto(6); printf("%d", take()); printf("%d", take());
}
==> 213613
```
10. 데이터베이스 구축 과정
```
1. 요구조건 분석 -> 2. 개념적 설계 -> 3.논리적 설계 -> 4.물리적 설계 -> 5. 데이터베이스 구현
```
11. 디자인 패턴  
    1. 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 패턴으로, 불필요한 메모리 낭비를 최소화 할 수 있음
    2. 방문자 : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도로 구성함으로써, 클래스를 수정하지 않고도 새로운 연산의 추가가 가능함


12. 전송오류 제어
- 전송 오류의 발생에는 감쇠, 지연 왜곡, 잡음 등 다양한 원인이 있으며, 이런한 오류를 검출하고 수정하는 것으로 알려진 대표적인 방식이 ( __Hamming__ ) 코드 방식이다.  
(__Hamming__) 코드 방식은 하나의 데이터 단위에  ( __Parity__  ) 비트를 추가하여 오류를 검출하여 고정이 가능한 코드로, __2bit__ 의 오류를 검출할 수 있으며 __1bit__ 의 오류를 교정한다. 데이터 비트 외에 잉여 비트가 많이 필요하다는 단점이 있다.  
(__Hamming__) 코드 방식은 수신측에서 오류를 정정하는 ( __FEC__ )에 해당한다. ( __FEC__ )는 데이터 전송 과정에서 오류가 발생하면 송신측에 재전송을 요구하는 ( __BEC__ )와는 달리 재전송 요구 없이 스스로 수정하기 때문에 연속적인 데이터 전송이 가능하다.  
( __BEC__ ) 는 ( __Parity__ ) 검사, ( __CRC__ ) 등을 통해 오류를 검출하고 ARQ(Automatic Repeat reQuest)로 오류를 제어한다.  
( __Parity__ ) 검사는 오류 검사를 위해 데이터 비트 외에 1 bit의 체크 비트를 추가하는 거으로 1bit의 오류만 검출할 수 있다. 1의 개수에 따라 짝수 (__Parity__  )와 홀수 (__Parity__ )로 나뉜다.  
( __CRC__ ) 는 다항식 코드를 사용하여 오류를 검출하는 방식이다. 동기식 전송에서 주로 사용되며, HDLC 프레임의 FCS(프레임 검사 순서 필드)에 사용되는 방식이다. 집단 오류를 검출할 수 있고, 검출률이 높으므로 가장 많이 사용한다.  
==> __1. Hamming   2. FEC    3.  BEC    4. Parity    5. CRC__

* 후진 오류 정정(Backward Error correction, BEC)
    - 오류가 발새앟면 역방향 채널을 통해 송신 측에 재전송을 요구하는 방식.
      Parity, CRC 등을 사용하여 오류를 검출하고, 오류 정정은 자동 반복 요청(ARQ)으로 수행함.
        * 자동 반복 요첨(ARQ;Automatic Repeat reQuest)
        - 정지 - 대기(Stop and Wait) ARQ
        - 연속(Continuous) ARQ - Go-Back-N ARQ
                               - 선택적 재전송(Selective Repeat) ARQ
        - 적응적(Adaptive) ARQ

* 패리티 검사(Parity Check)
    - 데이터 블록에 1비트의 검사 비트인 패리티 비트(Parity Bit)를 추가하여 오류를 검출함.
    - 가장 간단한 방식이지만, 2개의 비트에 오류가 동시에 발생하면 검추링 불가능함.
    - 오류를 검출만 할 수 있고, 수정은 하지 못함.
    - 홀수 /짝수 수직 패리티 체크와 홀수/짝수 수평 패리티 체크가 있음.
* 순환 중복 (잉여) 검사(CRC)
    - 프레임 단위로 오류 검출을 위한 다항식 코드(FCS) 를 사용하여 오류를 검출하는 방식.
    - 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 후진 오류 수정방식(BEC).
    - 동기식 전송에 사용되는 에러 겈출 ㅣㄱ법으로 데이터가 프레임 단위로 전송될 때 사용됨.
    - HDLC 프레임의 FCS(프레임 검사 순서 필드)를 만드는 방법으로 사용됨.
    - 집단 오류를 검출할 수 있고, 검출률이 높으므로 가장 많이 사용됨.

* 전진오류 정정(Forward Error correction, FEC)
    - 데이터 전송 과정에서 발생한 오류를 검출하여 스스로 수정하는 방식
    - Hamming Code 를 사용하여 오류 검출/수정함.

* 해밍 코드(Hamming Code)
    - 수신 측에서 오류가 발생한 비트를 검출한 수 직접 수정하는 전진 오류 수정 방식(FEC)
      으로 자기 정정 부호라고도 함.
    - 하나의 데이터 단위에 피리티 비트를 추가하여 오류를 검출하여 교정이 가능한 코드로, 
      2bit의 오류를 검춯 할 수 있으며 1bit 의 오류를 교정함.
    - 정보 비트 외에 잉여 비트가 많이 필요함.
    - 전송 비트 중 1,2,4,8, 16, 32, 64, ~~~ , (2의 n제곱)번째를 오류 검출을 위한 패리티 비트로 사용함.

13. HDLC(Hige-level Data Link control)는 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 보정할 수 있는 비트 열을 삽입하여 전송함.
    - 포인트 투 포인트 및 멀티 포인트, 루프 방식에서 모두 사용 가능함.
    - 단방향, 반이중, 전이중 통신을 모두 지원하며 동기식 전송 방식을 사용함.
    - 에러 제어를 위해 Go-Back-N ARQ 와 선택적 재전송(Selective Repeat) ARQ를 사용함.
    - 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용함.
    - 전송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송할 수 있음(비트 투과성)
    - 전송 효율과 신뢰성이 높다.
    - HDLC의 데이터 전송 모드 : 표준(정규) 응답 모드(NRM), 비동기 응답 모드(ARM),
      비동기 균형(평형) 모드(ABM)  
    HDLC의 프레임 구조는 헤더, 텍스트, 트레일러로 구분되며, 헤더는 다시 플래그, 주소부, 제어부로 구분할 수 있는데, 제어부에는 프레임의 종류를 식별하기 위해 사용한다.   제어부의 첫번째, 두번째 비트를 사용하여 (정보) 프레임, (감독) 프레임, (비번호) 프레임으로 구분한다.  
    (정보) 프레임은 I 프레임으로 불리며, 제어부가 '0'으로 시작하는 프레임으로, 사용자   데이터를 전달하거나 피기백킹(Piggybacking) 기법을 통해 데이터에 대한 확인 응답을 보낼 때  사용 된다.  
    (감독) 프레임은 S프레임으로 불리며, 제어부가 '10'으로 시작하는 프레임으로, 오류 제어와 흐름 제어를 위해 사용된다.
    (비번호) 프레임은 U 프레임으로 불리며, 제어부가 '11'로 시작하는 프레임으로, 링크의 동작 모드 설정과 관리를 한다.

    * (비번호) 프레임에서 설정할 수 있는 동작 모드에는 표준 응답모드, 비동기 균형 모드, 비동기 응답모드의 세 가지로 구분된다.
    표준 응답 모드는 반이중 통신을 하는 포인트 투 포인트 또는 멀티 포인트 불균형 링크 구성에 사용되며, 종국은 주국의 허가가 있을 때에만 송신하는 특징이 있다.
    비동기 균형 모드는 포인트 투 포인트 균형 링크에 사용되며, 혼합국끼리 허가 없이 언제나 전송할 수 있다.
    비동기 응답 모드 는 전이중 통신을 하는 포인트 투 포인트 불균형 링크 구성에 사용되며, 종국은 주국의 허가 없이도 송신이 가능하지만 링크 설정이나 오류 복구 등의 제어 기능은 주국만 가능하다.

    
14. java 결과
```java
public class Test{
    public static void main(String[] args){
        String str1= "Programming";
        String str2= "Programming";
        String str3= new String("Programming");
        System.out.println(str1==str2);
        System.out.println(str1==str3);
        System.out.println(str1.equals(str3));
        System.out.println(str2.equals(str3));
    }
}
==> true
    false
    true
    true

```
15. 암호화 알고리즘
    - 대칭키 암호화 알고리즘 : DES, ARIA, SEED, AES
    - 비대칭키 암호화 알고리즘 : RSA, ECC

```
암호 알고리즘
- 암호 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화 된 문장으로 만드는 절차 또는 방법을 의미함
- 암호 방식 분류
암호화 방식 - 양방향 - 개인 키 - Stream 방식
                             - Block  방식
                    - 공개 키 
           - 단방향 - HASH
```
- 개인키 암호화(Private Key Encryption) 기법
    - 개인키 암호화 기법은 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법
    - 대칭 암호 기법 또는 단일키 암호화 기법이라고도 함
    - 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많음
    - 개인키 암호화 기법의 종류
    스트림 암호화 방식 - 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화하는 방식
                      - 종류 : LFSR, RC4, TKIP
    블록 암호화 방식 - 한 번에 하나의 데이터 블록을 안호화 하는 방식
                    - 종류 : DES, SEED, AES, ARIA, IDEA, Skipjack
- 공개키 암호화(Public Key Encryption) 기법
    - 공개키 암호화 기법은 데이터를 암호화할 때 사용하는 공개키는 사용자에게 공개하고, 복호화할 대의 비밀키는 관리자가 비밀리에 완리하는 암호화 기법
    -비대칭 암호 기법이라고도 함
    - 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느림
    - 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있음


* 양방향 알고리즘의 종류
    - SEED : 
        - 1999년 한국인터넷진흥원(KISA)에서 개발한 블록 암호화 알고리즘
        - 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류 됨
    - ARIA(Academy, Research Institue, Agency) :
        - 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘
    - DES : 
        - 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘
        - 블록 크기는 64비트, 키 길이는 56비트이며 16회의 라운드를 수행함
        - DES 를 3번 적용하여 보안으르 더욱 강화한 3DES 도 있음
    - AES : 
        - 2001년 미국 표준 기술 연구소 (NIST)에서 발표한 개인키 암호화 알고리즘
        - DES 의 한계를 느낀 NIST에서 공모한 수 발표
        - 블록 크기는 128비트이며, 키 길이에 따라 AES-128, AES-192, AES-256으로 분류 됨
    - RSA(Rivest Shamir Adleman)
        - 1978년 MIT의 라이베스트(Rivest), 샤미르(Shamir), 애들먼(Adelman)에 의해 제안된 공개키 암호화 알고리즘
        - 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어짐
    - ECC(Elliptic Curve Cryptography) 
        - 1985년 RSA 암호 방식의 대안으로 제안되었음.
        - 이산대수 문제를 나원곡선으로 옮겨 기밀성과 효율성을 높인 암호화 알고리즘.
    - IDEA(International Data Encryption Algorithm)
        - 스위스의 라이와 메시가 1990년에 개발한 PES를 개선한 알고리즘
        - 블록 크기는 64비트이고, 키 길이는 128비트임
        - 1991년에 제작된 블록 암호 알고리즘으로 현재 가장 안전하고 최고라고 여겨짐.
        블록 초당 177Mbit 의 빠른 처리가 가능함.
        그러나 0이 많이 들어간 키 같은 특정키에 대해서는 취약함.
    - Skipjack 
        - 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘
        - 클리퍼 칩(Clipper Chip) 이라는 IC칩에 내장되어 있음
        - 블록 크기는 64비트이고, 키 길이는 80비트임
        - 주로 음성 통신 장비에 삽입되어 음성 데이터를 암호화함
    - TKIP(Temporal Key Integrity Protocol)
        - 무선랜 보안에 사용된 WEP을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라고도 함
        - WEP 의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등 키 관리 방식을 개성하였음    

16. 암호화 알고리즘
```
해시 는 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 알고리즘으로, 복화화가 거의 불가능한 일방향 함수이다. 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 당야한 분야에서 활용되며, 종류에는 SHA 시리즈,MD5, N-NASH, SNEFRU 등이 있다.

```
17. <처리조건>에 부합하는 <SQL문> 이 완성되도록 괄호에 적합한 옵션을 쓰시오.
    <처리조건>
    ```
    - <학생> 뷰를 제거한다.
    - <학생> 뷰를 참조하는 모든 데이터도 연쇄적으로 제거하낟.
    ```
DROP VIEW 학생 CASCADE;

* CREATE 
    - CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_ID;
    --------------------------------------
    - CREATE DOMAIN 도메인명 [AS] 데이터_타입
      [DEFAULT 기본값]
      [CONSTRATINT 제약조건명 CHECK (범위값)];
    --------------------------------------
    - CREATE VIEW 뷰명[(속성명[, 속성명, ...])]
      AS SELECT문;
    --------------------------------------
    - CREATE [UNIQUE] INDEX 인덱스명
      ON 테이블명(속성명[ASC|DESC][,속성명[ASC|DESC]])
      [CLUSTER];
    --------------------------------------

18. 오름차순 정렬 선택정렬 알고리즘
```C
#include <stdio.h>
    main(){
        int E[] = {64, 25, 12, 22, 11};
        int n = sizeof(E) / sizeof(E[0]);
        int i = 0;
    do{
        int j = i+1;
        do {
            if (E[i] > E[j]){
                int tmp = E[i];
                E[i] = E[j];
                E[j] = tmp;
            }
            j++;
        }while(i < n);
        i++;
    }while(i< n-1);
    for(int i= 0; i<=4;i++)
        printf("%d",E[i]);
    }
```
19. Python  으로 구현된 프로그램을 분석하여 그 실행 결과를 쓰시오.
    (단, 출력문의 출력 서식을 준수하시오.)
```python
    a="engineer information programming"
    b=a[:3]
    c=a[4:6]
    d=a[29:]
    e=b+c+d
    print(e)
    ==> engneing
```
20. 하향식 통합 테스트는 프로그램의 상위 모듈에서 하위 모듈 바향을 통합하면서 테스트하는 기법이다. 깊이 우선 통합법이나 넓이 우선 통합법을 사용하며, 주요 제어 모듈의 종속 모듈들을 스텁으로 대체한다는 특징이 있다.
상향식 통합 테스트는 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법이다. 하위 모듈들을 클러스터로 결합하며, 상위 모듈에서 데이터의 입출력을 확인하기 위해 더미 모듈인 드라이버를 작성한다는 특징이 있다.
