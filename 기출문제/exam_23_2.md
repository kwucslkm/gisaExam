1. c언어 결과가 "43215" 일 때, 괄호 안에 들어갈 알맞은 식
```c
#include <stdio.h>
main(){
    int n[] = {5,4,3,2,1};
    for (int i=0;i<5; i++)
        printf("%d", n[(i+1)%5]);
}
    ==> n[(i+1)%5]
```
2. c언어 
```c
#include < stdio.h>
main(){
    int m = 4620;
    int a = (m/1000);
    int b = (m%1000/500);
    int c = (m%500/100);
    int d = (m%100/10);
    printf("1000원의 개수: %d\n",a);
    printf("500원의 개수: %d\n",b);
    printf("100원의 개수: %d\n",c);
    printf("10원의 개수: %d\n",d);
}
```
3. c 언어 "홍길동" "김철수" "박영희"
```c
#include <stdio.h>
char n[30];
char* getname(){
    printf("이름입력:");
    gets(n);
    return n;
}
main() {
    char* n1 = getname();
    char* n2 = getname();
    char* n3 = getname();
    printf("%s\n", n1);
    printf("%s\n", n2);
    printf("%s\n", n3);
}
```
```
박영희
박영희
박영희
```

4. <학생> 테이블에 (9816021, '한국산',3,'경영학개론','050-1234-1234')인 데이터를 삽입하고자 한다. <처리조건>을 참고하여 적합한 SQL문을 작성하시오.  
    ```
    - 최소한의 코드로 작성될수
    - 명령문 마지막의 세미콜론은 생략이 가능하다.
    - 인용부호가 필요한 경우 작은따옴표를 사용한다.
    ```
    ```sql
    => insert into 학생 values (9816021, '한국산', 3, '경영학개론', '050-1234-1234');
    ```

5. c언어 결과
```c
#include <stdio.h>
main(){
    int n[] = {73, 95, 82};
    int sum =0;
    for (int i=0; i<3; i++)
        sum += n[i];
    switch (sum /30){
        case 10:
        case 9: printf("A");
        case 8: printf("B");
        case 7:
        case 6: printf("C");
        default: printf("D");
    }
}
==> BCD
```

6. 화이트박스 테스트의 검증 기준 ==> 조건 커버리지
```
테스트 케이스를 소스 코드의 ㅣ조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 설계한다.
```
* 화이트박스 테스트 - 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
    - 기초 경로 검사 : 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
    - 제어 구조 검사 : 조건 검사, 루프 검사, 데이터 흐름 검사
    * 화이트 박스 테스트 검증기준
        - 문장 검증 기준 : 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계
        - 분기 검증 기준 : 소스 코드의 모든 조건문에 대해 조건식의 결과가 True인 경우와 False 인 경우가 한 번 이상 수행 되도록 테스트 케이스를 설계함
        - 분기/조건 기준 : 조건문이 True 인 경우와 False 인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스를 설계함
* 블랙 박스 테스트 - 각 기능이 완전히 작동되는 것을 입증하는 테스트
    - 동치 분할 검사
    - 경계값 분석
    - 원인 효과 그래프 검사
    - 오류 예측 검사
    - 비교 검사

7. C언어 결과
```c
#include <stdio.h>
main(){
    int c=0;
    for (int i=1; i<=2003;i++)
        if(i%4==0)
            c++;
    printf("%d",c);
}
==> 505
```
8. 소프트웨어 데이터의 비정상적인 수정이 감지되면 소프트웨어를 오작동하게 만들어 악용을 방지하는 기술이다. 해시 함수, 핑거 프린트, 워터마킹 등의 보안 요소를 생성하여 소프트웨어에 삽입하고, 실행코드를 난독화하며, 실행 시 원본 비교 및 데이터 확인을 수행함으로써 소프트웨어를 보호하는 이 기술을 가리키는 용어를 쓰시오.
==> 템퍼 프루핑 Tamper Proofing

* 보안 솔루션
    - 보안 솔루션이란 접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템을 말함
    - 주요 보안 솔루션
        - 방화벽 
            - 방화벽은 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용 거부 수정 하는 기능을 가진 침입 차단 시스템
            - 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조임
        - 침입 탐지 시스템(IDS: Intrusion Detection System)
            - 침입 탐지 시스템은 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
            - 오용 탐지(Misuse Detection) : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌
            - 이상 탐지(Anomaly Detection) : 편균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
        - 침입 방지 시스템(IPS : Intrusion Prevention System)
            - 침입 방지 시스템은 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션
            - 침입 방지 시스템은 방화벽과 침입 탐지 시스템을 결합한 것
            - 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단함            
        - 데이터 유출 방지(DLP : Data Leakage/Loss Prevention)
            - 데이터 유출 방지는 내부 정보의 외부 유출을 방지하는 보안 솔루션
            - 사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 메일, 메신저, 웹하드, 네트워크 프린터 등의 사용자 행위를 탐지 통제해 외부로의 유출을 사전에 막음
        - 웹 방화벽(Web firewall)
            - 웹 방화벽은 일반 방화벽이 탐지 못하는 SQL삽입공격, Cross-Site Scription(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽
            - 웹 관련 공격을 감시하고공격이 웹 서버에 도달하기 전에 이를 차단해 줌
        - VPN(Virtual Private Network, 가상 사설 통신망)
            - VPN 은 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는  
              보안 솔루션.
            - SSL VPN 
                - PC에 VPN Client 프로그램을 설치하여 VPN 서버에 접속하는 방식으로, 암호화를 위해 SSL 프고토콜을 사용함
            - IPSec VPN 
                - VPN  서버가 설치된 각각의 네트워크를 서로 연결하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용함
        - NAC(Network Access Control)
            - NAC 은 네트워크에 접속하는 내부 PC의 MAC 주소를 IP관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
            - 내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지함
        - SIEM(Security Information and Event Management)
            - SIEM 은 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합관리하는 빅 데이터 기반의 보안 솔루션.
            - 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있음
            - 장기간의 로그 및 보안 이벤트를 수집 및 검색할 수 있는 빅데이터 기반의 통합 로그 수집 시스템.
            - __SIM(Security Information Management) + SEM(Security Event Management)__
        * ESM(Enterprise Security Management)
            - SIEM과 기능은 동일하지만 잛은 기간의 로그 및 보안 이벤트를 관리하는 보안 솔루션            
        - SSH(Secure SHell, 시큐어 셸)  
            - SSH는 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램
            - 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신 할 수 있음
            - 키를 통한 인증 방업을 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 함.
            - 기본적으로는 22번 포트를 사용함
        - 템퍼 프루핑(Tamper Proofing)
            - 템퍼 프루핑은 소프트웨어의 위변조가 발생할 경우 소프트웨어를 오작동하게 만들어 악용을 방지하는 기술
            - 템퍼 프루핑은 해시 함수(Hash Function), 핑거 프린트(Fingerprint), 워터마킹(Watermark) 등의 보안 요소를 생성하여 소프트웨어에 삽입하고, 실행 코드를 난독화하며, 실행 시 원본 비교 및 데이터 확인을 수행함으로써 소프트웨어를 보호함
        - OAuth(Open Authorization, 공개인증)
            - 인터넷 애플리케이션에서 사용자 인증에 사용되는 공개 API(OpenAPI)로 구현된 표준 인증 방법
            - 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있음.
            - 2010년 ETF에서 1.0이 공식 표준안으로 발표되었음.

9. c언어 결과
```c
#include <stdio.h>
#define MAX_SIZE 10

int isWhat[MAX_SIZE];
int point = -1;

int isEmpty(){
    if (point == -1 ) return 1;
    return 0;
}
int isFull(){
    if (point == 10) return 1;
    return 0;
}
void into(int num){
    if(isFull() ==1 ) printf("Full");
    else iswhat[++point] = num;
}
int take(){
    if(isEmpty() == 1) printf("Empty");
    else return isWhat[point--];
    return 0;
}
main(){
    into(5); into(2);
    while(!isEmpty());
        printf("%d", take());
        into(4); into(1); printf("%d", take());
        into(3); printf("%d", take()); printf("%d", take());
        intto(6); printf("%d", take()); printf("%d", take());
}         2
==> 213465
```
10. 데이터베이스 구축 과정
```
1. 요구조건 분석 -> 2. 개념적 설계 -> 3.논리적 설계 -> 4.물리적 설계 -> 5. 데이터베이스 구현
```
11. 디자인 패턴  
    1. 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 패턴으로, 불필요한 메모리 낭비를 최소화 할 수 있음
    2. 방문자 : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도로 구성함으로써, 클래스를 수정하지 않고도 새로운 연산의 추가가 가능함

# 디자인 패턴은 모듈 간의 관계 및 인터페이스를 설게할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미함.
   GOF의 디자인패턴은 생성패턴, 구조패턴, 행위패턴으로 구분됨.
 * 생성 패턴 : 클래스나 객체의 생성과 참조 과정을 정의하는 패턴.
    - 추상팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함.
    - 빌더(Builder) : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함.
        객체의 생성 과정과 표현 방법을 분리하고 잇어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음
    - 팩토리 메소드(Factory Method) : 가상 생성자(Virtual Constructor) 패턴
        객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화 한 패턴으로 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함
    - 프로토타입(Prototype) : 원본 객체를복제하는 방법으로 객체를 생성하는 팬턴으로 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함
    - 싱글톤(Singleton) : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없고, 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있음
 * 구조 패턴 : 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
    - 어댑터(Adapter) : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이요할 수 있도록 변환해주는 패턴으로, 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함
    - 브리지(Bridge) : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성 한 패턴으로 , 기능과 구현을 두 개의 별도 클래스로 구현함
    - 컴포지트(Composite) : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴으로, 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현 할 수 있음
    - 데코레이터(Decorator) : 객체간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴으로, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함
    - 퍼싸드(Facade) : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴으로, 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함
    - 플라이웨이트(Flyweight) : 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴으로, 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
    - 프록시(Proxy) : 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴으로, 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함.
 * 행위 패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
    - 책임연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 객체가 둘 이상  
      존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴으로, 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
    - 커맨드(Command) : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소 할 수 
      있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴으로 , 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화 함
    - 인터프리터(Interpreter) : 언어에 문법 표현을 정의하는 패턴으로, SQL이나 통신 
      프로토콜과 같은 것을 개발할 때 사용함
    - 반복자(Iterator) : 자료 구조와 같이 잦은 객체에 대해 동일한 인터페이스를 
      사용하도록 하는 패턴으로, 내부 표현 방법의 노출 없이 순차적인 접근이
    - 중재자(Mediator) : 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 
      객체로 정의하는 패턴으로, 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
    - 메멘토(Memento) : 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 
      따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴으로, ctrl+z와 
      같은 되돌리기 기능을 개발할 때 주로 이용함
    - 옵서버(Observer) : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 
      객체들에게 변화 된 상태를 전달하는 패턴으로, 일대다의 의존성을 정의함, 주로 분산된 시스템 간에 이벤트를 생성 발행 하고 , 수신 해야 할 때 이용함
    - 상태(State) : 객체의 상태에 따라 동일한 동작으르 다르게 처리해야 할 때 
      사용하는 패턴으로, 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함
    - 전략(Strategy) : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 
      수 있게 정의하는 패턴으로, 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 
      사용할 수 있수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함
    - 템플릿 메소드(Template Method) : 상위 클래스에서 골격을 정의하고, 하위 클래스
      에서 세부 처리를 구체화하는 구조의 패턴으로, 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌
    - 방문자(Visitor) : 각 클래스들ㄷ의 데이터 구조에서 처리 기능을 분리하여 별도의 
      클래스로 구성하는 패턴으로, 분리된 처리 기능은 각 클래스를 방문(visit)하여 수행

12. 전송오류 제어
- 전송 오류의 발생에는 감쇠, 지연 왜곡, 잡음 등 다양한 원인이 있으며, 이런한 오류를 검출하고 수정하는 것으로 알려진 대표적인 방식이 ( __Hamming__ ) 코드 방식이다.  
(__Hamming__) 코드 방식은 하나의 데이터 단위에  ( __Parity__  ) 비트를 추가하여 오류를 검출하여 고정이 가능한 코드로, __2bit__ 의 오류를 검출할 수 있으며 __1bit__ 의 오류를 교정한다. 데이터 비트 외에 잉여 비트가 많이 필요하다는 단점이 있다.  
(__Hamming__) 코드 방식은 수신측에서 오류를 정정하는 ( __FEC__ )에 해당한다. ( __FEC__ )는 데이터 전송 과정에서 오류가 발생하면 송신측에 재전송을 요구하는 ( __BEC__ )와는 달리 재전송 요구 없이 스스로 수정하기 때문에 연속적인 데이터 전송이 가능하다.  
( __BEC__ ) 는 ( __Parity__ ) 검사, ( __CRC__ ) 등을 통해 오류를 검출하고 ARQ(Automatic Repeat reQuest)로 오류를 제어한다.  
( __Parity__ ) 검사는 오류 검사를 위해 데이터 비트 외에 1 bit의 체크 비트를 추가하는 거으로 1bit의 오류만 검출할 수 있다. 1의 개수에 따라 짝수 (__Parity__  )와 홀수 (__Parity__ )로 나뉜다.  
( __CRC__ ) 는 다항식 코드를 사용하여 오류를 검출하는 방식이다. 동기식 전송에서 주로 사용되며, HDLC 프레임의 FCS(프레임 검사 순서 필드)에 사용되는 방식이다. 집단 오류를 검출할 수 있고, 검출률이 높으므로 가장 많이 사용한다.  
==> __1. Hamming   2. FEC    3.  BEC    4. Parity    5. CRC__

* 후진 오류 정정(Backward Error correction, BEC)
    - 오류가 발새앟면 역방향 채널을 통해 송신 측에 재전송을 요구하는 방식.
      Parity, CRC 등을 사용하여 오류를 검출하고, 오류 정정은 자동 반복 요청(ARQ)으로 수행함.
        * 자동 반복 요첨(ARQ;Automatic Repeat reQuest)
        - 정지 - 대기(Stop and Wait) ARQ
        - 연속(Continuous) ARQ - Go-Back-N ARQ
                               - 선택적 재전송(Selective Repeat) ARQ
        - 적응적(Adaptive) ARQ

* 패리티 검사(Parity Check)
    - 데이터 블록에 1비트의 검사 비트인 패리티 비트(Parity Bit)를 추가하여 오류를 검출함.
    - 가장 간단한 방식이지만, 2개의 비트에 오류가 동시에 발생하면 검추링 불가능함.
    - 오류를 검출만 할 수 있고, 수정은 하지 못함.
    - 홀수 /짝수 수직 패리티 체크와 홀수/짝수 수평 패리티 체크가 있음.
* 순환 중복 (잉여) 검사(CRC)
    - 프레임 단위로 오류 검출을 위한 다항식 코드(FCS) 를 사용하여 오류를 검출하는 방식.
    - 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 후진 오류 수정방식(BEC).
    - 동기식 전송에 사용되는 에러 겈출 ㅣㄱ법으로 데이터가 프레임 단위로 전송될 때 사용됨.
    - HDLC 프레임의 FCS(프레임 검사 순서 필드)를 만드는 방법으로 사용됨.
    - 집단 오류를 검출할 수 있고, 검출률이 높으므로 가장 많이 사용됨.

* 전진오류 정정(Forward Error correction, FEC)
    - 데이터 전송 과정에서 발생한 오류를 검출하여 스스로 수정하는 방식
    - Hamming Code 를 사용하여 오류 검출/수정함.

* 해밍 코드(Hamming Code)
    - 수신 측에서 오류가 발생한 비트를 검출한 수 직접 수정하는 전진 오류 수정 방식(FEC)
      으로 자기 정정 부호라고도 함.
    - 하나의 데이터 단위에 피리티 비트를 추가하여 오류를 검출하여 교정이 가능한 코드로, 
      2bit의 오류를 검춯 할 수 있으며 1bit 의 오류를 교정함.
    - 정보 비트 외에 잉여 비트가 많이 필요함.
    - 전송 비트 중 1,2,4,8, 16, 32, 64, ~~~ , (2의 n제곱)번째를 오류 검출을 위한 패리티 비트로 사용함.

13. HDLC(Hige-level Data Link control)는 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 보정할 수 있는 비트 열을 삽입하여 전송함.
    - 포인트 투 포인트 및 멀티 포인트, 루프 방식에서 모두 사용 가능함.
    - 단방향, 반이중, 전이중 통신을 모두 지원하며 동기식 전송 방식을 사용함.
    - 에러 제어를 위해 Go-Back-N ARQ 와 선택적 재전송(Selective Repeat) ARQ를 사용함.
    - 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용함.
    - 전송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송할 수 있음(비트 투과성)
    - 전송 효율과 신뢰성이 높다.
    - HDLC의 데이터 전송 모드 : 표준(정규) 응답 모드(NRM), 비동기 응답 모드(ARM),
      비동기 균형(평형) 모드(ABM)  
    HDLC의 프레임 구조는 헤더, 텍스트, 트레일러로 구분되며, 헤더는 다시 플래그, 주소부, 제어부로 구분할 수 있는데, 제어부에는 프레임의 종류를 식별하기 위해 사용한다.   제어부의 첫번째, 두번째 비트를 사용하여 (정보) 프레임, (감독) 프레임, (비번호) 프레임으로 구분한다.  
    (정보) 프레임은 I 프레임으로 불리며, 제어부가 '0'으로 시작하는 프레임으로, 사용자   데이터를 전달하거나 피기백킹(Piggybacking) 기법을 통해 데이터에 대한 확인 응답을 보낼 때  사용 된다.  
    (감독) 프레임은 S프레임으로 불리며, 제어부가 '10'으로 시작하는 프레임으로, 오류 제어와 흐름 제어를 위해 사용된다.
    (비번호) 프레임은 U 프레임으로 불리며, 제어부가 '11'로 시작하는 프레임으로, 링크의 동작 모드 설정과 관리를 한다.

    * (비번호) 프레임에서 설정할 수 있는 동작 모드에는 표준 응답모드, 비동기 균형 모드, 비동기 응답모드의 세 가지로 구분된다.
    표준 응답 모드는 반이중 통신을 하는 포인트 투 포인트 또는 멀티 포인트 불균형 링크 구성에 사용되며, 종국은 주국의 허가가 있을 때에만 송신하는 특징이 있다.
    비동기 균형 모드는 포인트 투 포인트 균형 링크에 사용되며, 혼합국끼리 허가 없이 언제나 전송할 수 있다.
    비동기 응답 모드 는 전이중 통신을 하는 포인트 투 포인트 불균형 링크 구성에 사용되며, 종국은 주국의 허가 없이도 송신이 가능하지만 링크 설정이나 오류 복구 등의 제어 기능은 주국만 가능하다.

    
14. java 결과
```java
public class Test{
    public static void main(String[] args){
        String str1= "Programming";
        String str2= "Programming";
        String str3= new String("Programming");
        System.out.println(str1==str2);
        System.out.println(str1==str3);
        System.out.println(str1.equals(str3));
        System.out.println(str2.equals(str3));
    }
}
==> true
    false
    true
    true

```
15. 암호화 알고리즘
    - 대칭키 암호화 알고리즘 : DES, ARIA, SEED, AES
    - 비대칭키 암호화 알고리즘 : RSA, ECC

```
암호 알고리즘
- 암호 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화 된 문장으로 만드는 절차 또는 방법을 의미함
- 암호 방식 분류
암호화 방식 - 양방향 - 개인 키 - Stream 방식
                             - Block  방식
                    - 공개 키 
           - 단방향 - HASH
```
- 개인키 암호화(Private Key Encryption) 기법
    - 개인키 암호화 기법은 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법
    - 대칭 암호 기법 또는 단일키 암호화 기법이라고도 함
    - 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많음
    - 개인키 암호화 기법의 종류
    스트림 암호화 방식 - 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화하는 방식
                      - 종류 : LFSR, RC4, TKIP
    블록 암호화 방식 - 한 번에 하나의 데이터 블록을 안호화 하는 방식
                    - 종류 : DES, SEED, AES, ARIA, IDEA, Skipjack
- 공개키 암호화(Public Key Encryption) 기법
    - 공개키 암호화 기법은 데이터를 암호화할 때 사용하는 공개키는 사용자에게 공개하고, 복호화할 대의 비밀키는 관리자가 비밀리에 완리하는 암호화 기법
    -비대칭 암호 기법이라고도 함
    - 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느림
    - 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있음


* 양방향 알고리즘의 종류
    - SEED : 
        - 1999년 한국인터넷진흥원(KISA)에서 개발한 블록 암호화 알고리즘
        - 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류 됨
    - ARIA(Academy, Research Institue, Agency) :
        - 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘
    - DES : 
        - 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘
        - 블록 크기는 64비트, 키 길이는 56비트이며 16회의 라운드를 수행함
        - DES 를 3번 적용하여 보안으르 더욱 강화한 3DES 도 있음
    - AES : 
        - 2001년 미국 표준 기술 연구소 (NIST)에서 발표한 개인키 암호화 알고리즘
        - DES 의 한계를 느낀 NIST에서 공모한 수 발표
        - 블록 크기는 128비트이며, 키 길이에 따라 AES-128, AES-192, AES-256으로 분류 됨
    - RSA(Rivest Shamir Adleman)
        - 1978년 MIT의 라이베스트(Rivest), 샤미르(Shamir), 애들먼(Adelman)에 의해 제안된 공개키 암호화 알고리즘
        - 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어짐
    - ECC(Elliptic Curve Cryptography) 
        - 1985년 RSA 암호 방식의 대안으로 제안되었음.
        - 이산대수 문제를 나원곡선으로 옮겨 기밀성과 효율성을 높인 암호화 알고리즘.
    - IDEA(International Data Encryption Algorithm)
        - 스위스의 라이와 메시가 1990년에 개발한 PES를 개선한 알고리즘
        - 블록 크기는 64비트이고, 키 길이는 128비트임
        - 1991년에 제작된 블록 암호 알고리즘으로 현재 가장 안전하고 최고라고 여겨짐.
        블록 초당 177Mbit 의 빠른 처리가 가능함.
        그러나 0이 많이 들어간 키 같은 특정키에 대해서는 취약함.
    - Skipjack 
        - 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘
        - 클리퍼 칩(Clipper Chip) 이라는 IC칩에 내장되어 있음
        - 블록 크기는 64비트이고, 키 길이는 80비트임
        - 주로 음성 통신 장비에 삽입되어 음성 데이터를 암호화함
    - TKIP(Temporal Key Integrity Protocol)
        - 무선랜 보안에 사용된 WEP을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라고도 함
        - WEP 의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등 키 관리 방식을 개성하였음    

16. 암호화 알고리즘
```
해시 는 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 알고리즘으로, 복화화가 거의 불가능한 일방향 함수이다. 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 당야한 분야에서 활용되며, 종류에는 SHA 시리즈,MD5, N-NASH, SNEFRU 등이 있다.

```
17. <처리조건>에 부합하는 <SQL문> 이 완성되도록 괄호에 적합한 옵션을 쓰시오.
    <처리조건>
    ```
    - <학생> 뷰를 제거한다.
    - <학생> 뷰를 참조하는 모든 데이터도 연쇄적으로 제거한다.
    ==> DROP VIEW 학생 CASCADE;
    ```


* CREATE 
    - CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_ID;
    --------------------------------------
    - CREATE DOMAIN 도메인명 [AS] 데이터_타입
      [DEFAULT 기본값]
      [CONSTRATINT 제약조건명 CHECK (범위값)];
    --------------------------------------
    - CREATE VIEW 뷰명[(속성명[, 속성명, ...])]
      AS SELECT문;
    --------------------------------------
    - CREATE [UNIQUE] INDEX 인덱스명
      ON 테이블명(속성명[ASC|DESC][,속성명[ASC|DESC]])
      [CLUSTER];
    --------------------------------------

18. 오름차순 정렬 선택정렬 알고리즘
```C
#include <stdio.h>
    main(){
        int E[] = {64, 25, 12, 22, 11};
        int n = sizeof(E) / sizeof(E[0]);
        int i = 0;
    do{
        int j = i+1;
        do {
            if (E[i] > E[j]){
                int tmp = E[i];
                E[i] = E[j];
                E[j] = tmp;
            }
            j++;
        }while(i < n);
        i++;
    }while(i< n-1);
    for(int i= 0; i<=4;i++)
        printf("%d",E[i]);
    }
```
19. Python  으로 구현된 프로그램을 분석하여 그 실행 결과를 쓰시오.
    (단, 출력문의 출력 서식을 준수하시오.)
```python
    a="engineer information programming"
    b=a[:3]
    c=a[4:6]
    d=a[29:]
    e=b+c+d
    print(e)
    ==> engneing
```
20. 하향식 통합 테스트는 프로그램의 상위 모듈에서 하위 모듈 바향을 통합하면서 테스트하는 기법이다. 깊이 우선 통합법이나 넓이 우선 통합법을 사용하며, 주요 제어 모듈의 종속 모듈들을 (스텁)으로 대체한다는 특징이 있다.
상향식 통합 테스트는 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법이다. 하위 모듈들을 클러스터로 결합하며, 상위 모듈에서 데이터의 입출력을 확인하기 위해 더미 모듈인 (드라이버)를 작성한다는 특징이 있다.
